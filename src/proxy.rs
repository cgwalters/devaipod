//! Network isolation proxy for agent containers
//!
//! This module provides an HTTPS forward proxy that restricts agent network
//! access to only allowed domains (LLM API endpoints). The proxy uses squid
//! with a domain allowlist to enforce network isolation.
//!
//! Architecture:
//! - A squid proxy container runs in the pod
//! - The agent container has HTTP_PROXY/HTTPS_PROXY set to use the proxy
//! - The proxy only allows CONNECT to domains in the allowlist
//! - This provides defense-in-depth without requiring special privileges

use crate::config::NetworkIsolationConfig;
use crate::podman::ContainerConfig;

/// Port for the squid proxy
pub const PROXY_PORT: u16 = 3128;

/// Generate squid configuration for the allowlist
pub fn generate_squid_config(allowed_domains: &[String]) -> String {
    let mut config = String::new();

    config.push_str("# Generated by devaipod - network isolation proxy config\n\n");

    // ACL for allowed domains
    config.push_str("# Allowed domains for agent network access\n");
    for domain in allowed_domains {
        config.push_str(&format!("acl allowed_domains dstdomain {}\n", domain));
    }
    config.push('\n');

    // Standard SSL port ACL
    config.push_str("# SSL/TLS ports\n");
    config.push_str("acl SSL_ports port 443\n");
    config.push_str("acl CONNECT method CONNECT\n\n");

    // Access rules
    config.push_str("# Access control\n");
    config.push_str("http_access allow CONNECT SSL_ports allowed_domains\n");
    config.push_str("http_access deny all\n\n");

    // Proxy configuration
    config.push_str("# Proxy settings\n");
    config.push_str(&format!("http_port {}\n", PROXY_PORT));
    config.push_str("pid_filename /tmp/squid.pid\n");
    config.push_str("cache_log stdio:/dev/stderr\n");
    config.push_str("access_log stdio:/dev/stdout\n");
    // Minimal cache for API requests
    config.push_str("cache deny all\n");
    // Run without disk cache
    config.push_str("cache_dir null /tmp\n");

    config
}

/// Create container config for the proxy container
///
/// The proxy runs squid with the generated configuration.
pub fn proxy_container_config(network_config: &NetworkIsolationConfig) -> ContainerConfig {
    let allowed_domains = network_config.all_allowed_domains();
    let squid_config = generate_squid_config(&allowed_domains);

    let mut env = std::collections::HashMap::new();
    env.insert("HOME".to_string(), "/tmp".to_string());

    // We'll inject the squid config via the command - squid can read from stdin
    // Or we can create a temp file and mount it
    // For simplicity, we'll use a shell command to write the config and start squid
    let startup_script = format!(
        r#"#!/bin/sh
set -e
mkdir -p /tmp/squid
cat > /tmp/squid/squid.conf << 'SQUID_EOF'
{}
SQUID_EOF
exec squid -f /tmp/squid/squid.conf -N
"#,
        squid_config
    );

    ContainerConfig {
        mounts: vec![],
        env,
        workdir: None,
        user: None,
        command: Some(vec![
            "/bin/sh".to_string(),
            "-c".to_string(),
            startup_script,
        ]),
        // Minimal privileges
        drop_all_caps: true,
        cap_add: vec!["NET_BIND_SERVICE".to_string()],
        no_new_privileges: true,
    }
}

/// Get the proxy environment variables to set on the agent container
pub fn agent_proxy_env() -> Vec<(String, String)> {
    let proxy_url = format!("http://localhost:{}", PROXY_PORT);
    vec![
        ("HTTP_PROXY".to_string(), proxy_url.clone()),
        ("HTTPS_PROXY".to_string(), proxy_url.clone()),
        ("http_proxy".to_string(), proxy_url.clone()),
        ("https_proxy".to_string(), proxy_url.clone()),
        // Don't proxy localhost (for opencode <-> workspace communication)
        ("NO_PROXY".to_string(), "localhost,127.0.0.1".to_string()),
        ("no_proxy".to_string(), "localhost,127.0.0.1".to_string()),
    ]
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_squid_config() {
        let domains = vec![
            "api.anthropic.com".to_string(),
            "api.openai.com".to_string(),
        ];
        let config = generate_squid_config(&domains);

        assert!(config.contains("acl allowed_domains dstdomain api.anthropic.com"));
        assert!(config.contains("acl allowed_domains dstdomain api.openai.com"));
        assert!(config.contains("http_access allow CONNECT SSL_ports allowed_domains"));
        assert!(config.contains("http_access deny all"));
        assert!(config.contains(&format!("http_port {}", PROXY_PORT)));
    }

    #[test]
    fn test_proxy_container_config() {
        let network_config = NetworkIsolationConfig::default();
        let config = proxy_container_config(&network_config);

        // Verify security restrictions
        assert!(config.drop_all_caps);
        assert!(config.no_new_privileges);
        assert_eq!(config.cap_add, vec!["NET_BIND_SERVICE".to_string()]);

        // Verify command starts squid
        let cmd = config.command.as_ref().unwrap();
        assert_eq!(cmd[0], "/bin/sh");
        assert!(cmd[2].contains("squid"));
    }

    #[test]
    fn test_agent_proxy_env() {
        let env_vars = agent_proxy_env();
        let env_map: std::collections::HashMap<_, _> = env_vars.into_iter().collect();

        let expected_proxy = format!("http://localhost:{}", PROXY_PORT);
        assert_eq!(env_map.get("HTTP_PROXY"), Some(&expected_proxy));
        assert_eq!(env_map.get("HTTPS_PROXY"), Some(&expected_proxy));
        assert_eq!(
            env_map.get("NO_PROXY"),
            Some(&"localhost,127.0.0.1".to_string())
        );
    }
}
